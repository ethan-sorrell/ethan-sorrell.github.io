{"version":3,"sources":["sudoku_cljs/rules.cljs"],"mappings":";;;;AAKA,AAAA,AAAMA,AAAsBC;AAA5B,AAAA;AAEE,AAAMC,AAAK,AAACC,AAAOC,AAAIH;AAAvB,AACE,AAACI,AAAKH,AAAK,AAACI,AAASJ;;AAEzB,AAAA,AAAMK,AACHC,AAAOC;AADV,AAEE,AAACC,AAASC,AACT,AAAA,AAAAC,AAACC;AAAD,AAAM,AAAK,AAAAD,AAACZ;AACP,AAAA,AAAAc,AAACD;AAAD,AAAM,AAAAC,AAAAA,AAAAA,AAAGN,AAAAA,AAAOC,AAAAA;AAAhB,AAAwBM,AAAcC,AAAcC;;AAE5D,AAAA,AAAMC,AACHC,AAAGC,AAAYC;AADlB,AAEE,AACC,AAACrB,AACA,AAACsB,AAAuBH,AAAGC,AAAYC;;AAE3C,AAAA,AAAME,AACHC,AAAIC;AADP,AAEE,AAAOC,AAAID;;AAAX,AACE,AAAI,AAACE,AAAI,AAACvB,AAAIsB;AAAd;;AAEE,AAAAE,AAAyB,AAACG,AAAML;AAAhC,AAAAG,AAAAD,AAAA,AAAA,AAAOR;AAAP,AAAAS,AAAAD,AAAA,AAAA,AAAmBE;AAAnB,AACE,AAAI,AAAA,AAACG;AAADD;AAAA,AAAO,AAAAA,AAACE,AAAIV;;AAAK,AAAAW,AAAC,AAACC,AAAyBN;AAA3B,AAAA,AAAAK,AAAAA,AAAAA,AAAiCf,AAAAA;;AAAtD;;AAEE,AAAO,AAACiB,AAAKX","names":["sudoku-cljs.rules/contains-duplicates?","coll","elts","cljs.core.filter.cljs$core$IFn$_invoke$arity$2","cljs.core/seq","cljs.core.not_EQ_.cljs$core$IFn$_invoke$arity$2","cljs.core.distinct.cljs$core$IFn$_invoke$arity$1","sudoku-cljs.rules/valid-cell?","matrix","coord","cljs.core/not-any?","cljs.core/identity","p1__52692#","cljs.core.map.cljs$core$IFn$_invoke$arity$2","p1__52694#","sudoku-cljs.board/get-row","sudoku-cljs.board/get-col","sudoku-cljs.board/get-square","sudoku-cljs.rules/valid-neighborhood?","db","invalid-pos","invalid-type","sudoku-cljs.board/get-neighborhood","sudoku-cljs.rules/conflicting-pos?","pos","invalids","rem","cljs.core/not","vec__52705","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","type","cljs.core/first","p1__52697#","cljs.core/some","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","fexpr__52708","sudoku-cljs.board/neighborhood-peers","cljs.core/rest"],"sourcesContent":["(ns sudoku-cljs.rules\n  (:require\n   [clojure.string :as string]\n   [sudoku-cljs.board :as board]))\n\n(defn contains-duplicates? [coll]\n  \"Take a collection of strings representing a neighborhood\"\n  (let [elts (filter seq coll)]\n    (not= elts (distinct elts))))\n\n(defn valid-cell?\n  [matrix coord]\n  (not-any? identity\n   (map #(not (contains-duplicates? %))\n        (map #(% matrix coord) [board/get-row board/get-col board/get-square]))))\n\n(defn valid-neighborhood?\n  [db invalid-pos invalid-type]\n  (not\n   (contains-duplicates?\n    (board/get-neighborhood db invalid-pos invalid-type))))\n\n(defn conflicting-pos?\n  [pos invalids]\n  (loop [rem invalids]\n    (if (not (seq rem))\n      false\n      (let [[invalid-pos type] (first rem)]\n        (if (some #(= % pos) ((board/neighborhood-peers type) invalid-pos))\n          true\n          (recur (rest rem)))))))\n\n"]}