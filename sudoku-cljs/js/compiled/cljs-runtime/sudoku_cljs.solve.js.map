{"version":3,"sources":["sudoku_cljs/solve.cljs"],"mappings":"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","names":["sudoku-cljs.solve/update-invalid-posns","db","new-invalids","old-invalids","G__52730","temp__5733__auto__","vec__52731","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","candidate-pos","candidate-type","cljs.core/first","sudoku-cljs.rules/valid-neighborhood?","cljs.core/rest","cljs.core/cons","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","sudoku-cljs.solve/elim","matrix","from","value","clojure.string/replace","cljs.core.get.cljs$core$IFn$_invoke$arity$2","cljs.core/re-pattern","sudoku-cljs.solve/candidate-locations","pos","iter__4523__auto__","s__52749","cljs.core/LazySeq","temp__5735__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4521__auto__","size__4522__auto__","cljs.core/count","b__52751","cljs.core/chunk-buffer","i__52750","cljs.core._nth.cljs$core$IFn$_invoke$arity$2","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__52748","cljs.core/chunk-rest","unit","cljs.core.conj.cljs$core$IFn$_invoke$arity$variadic","sudoku-cljs.board/square-peers","sudoku-cljs.board/row-peers","sudoku-cljs.board/col-peers","s__52756","b__52758","i__52757","iter__52755","s__52789","b__52791","i__52790","iter__52788","loc","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","clojure.string/includes?","sudoku-cljs.solve/propagate-in","result","rem-units","cljs.core/not","new-matrix","G__52809","G__52810","G__52811","sudoku-cljs.solve/assign","sudoku-cljs.solve/propagate-out","rem-peers","sudoku-cljs.board/all-peers","peer","sudoku-cljs.solve/eliminate","remaining-count","current_val","other_vals","rem","sudoku-cljs.solve/constrain-board","board","sudoku-cljs.board/unconstrained-board","pair","coord","vals","cljs.core/second","cljs.core/chunk-first"],"sourcesContent":["(ns sudoku-cljs.solve\n  (:require\n   [clojure.string :as string]\n   [sudoku-cljs.board :as board]\n   [sudoku-cljs.rules :as rules]))\n\n(defn update-invalid-posns\n  ;; TODO: could be modified to only check positions in \"zone\" of pos\n  [db]\n  (loop [new-invalids '()\n         old-invalids (db :invalid-cells)]\n    (if-let [[candidate-pos candidate-type] (first old-invalids)]\n      (if (rules/valid-neighborhood? db candidate-pos candidate-type)\n        (recur new-invalids (rest old-invalids))\n        (recur (cons [candidate-pos candidate-type] new-invalids) (rest old-invalids)))\n      (assoc db :invalid-cells new-invalids))))\n\n(declare assign elim eliminate)\n\n(defn elim [matrix from value]\n  \"Remove value from association with from in matrix\"\n  (assoc matrix from (string/replace (get matrix from) (re-pattern value) \"\")))\n\n(defn candidate-locations [matrix pos value]\n  \"takes value and returns list of list of coords in unit which could contains value\"\n  (for [unit (conj []\n                   (board/square-peers pos)\n                   (board/row-peers pos)\n                   (board/col-peers pos))]\n    (for [loc unit\n          :when (and (not (= loc pos))\n                     (string/includes? (get matrix loc) value))]\n      loc)))\n\n(defn propagate-in [matrix pos value]\n  \"Check if any unit containing pos is reduces to one possible location for a value\"\n  (when matrix\n    (loop [result matrix\n           rem-units (candidate-locations matrix pos value)]\n      (if-not (seq rem-units)\n        result\n        (when-not (= 0 (count (first rem-units)))\n          (if (= 1 (count (first rem-units)))\n            (if-let [new-matrix\n                     (assign result (first (first rem-units)) value)]\n              (recur new-matrix (rest rem-units))\n              false)\n            (recur result (rest rem-units))))))))\n\n(defn propagate-out [matrix pos]\n  \"Propagate a new constraint out from pos to its units\"\n  (let [value (get matrix pos)]\n    (loop [result matrix\n           rem-peers (board/all-peers pos)]\n      (if-let [peer (first rem-peers)]\n        (if (= peer pos)\n          (recur result (rest rem-peers))\n          (if-let [new-matrix (eliminate result peer value)]\n            (recur new-matrix (rest rem-peers))\n            false))\n        result))))\n\n(defn eliminate [matrix from value]\n  \"Elim and propagate\"\n  (if-not (string/includes? (get matrix from) value)\n    matrix\n    (let [new-matrix (elim matrix from value)\n          remaining-count (count (get new-matrix from))]\n      (cond\n        (= 0 remaining-count) false ;; no remaining possible values\n        ;; we have our value and need to propagate constraint\n        (= 1 remaining-count) (propagate-in (propagate-out new-matrix from) from value)\n        :else new-matrix))))\n\n(defn assign [matrix pos value]\n  \"Eliminate all other values associated with pos then propagate\"\n  (when matrix\n    (let [current_val (get matrix pos)\n          other_vals (string/replace current_val (re-pattern value) \"\")]\n      (loop [result matrix\n             rem other_vals]\n        (when result\n          (if (= 0 (count rem))\n            result\n            (recur (eliminate result pos (str (first rem))) (rest rem))))))))\n\n\n(defn constrain-board [board]\n  \"takes partially-filled in solution and outputs description of constraints\"\n  (loop [result board/unconstrained-board\n         rem board]\n    (when result\n      (if-not (seq rem)\n        result\n        (let [pair (first rem)\n              coord (first pair)\n              vals (second pair)]\n          (if-not (seq vals)\n            (recur result (rest rem))\n            (recur (assign result coord vals) (rest rem))))))))\n\n"]}